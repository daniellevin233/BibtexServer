import os
import re
import subprocess
import platform
import sqlite3
import json
import enum
from base64 import b64encode

#  csl file containing specification of citation rules to be applied, set to None for Chicago style
CITATION_STYLE_FILE = None # 'apa.csl'

#  temporary md file for holding citation generated by pandoc
TMP_CITATION_FILE = 'tmp_citation.md'

#  configuration file - specifies the .bib bibliography path and citation base rule
CONFIGURATIONS_BIBTEX = 'bib_config.md'

#  configuration file - specifies the .ris bibliography path and citation base rule
CONFIGURATIONS_RIS = 'bib_config_ris.md'

TABLE_NAME = 'bibliography'

class BibtexEntryTypes(enum.Enum): # TODO unnecessary?
   Article = "Article"
   Book = "Book"
   Booklet = "Booklet"
   Conference = "Conference"
   InBook = "InBook"
   InCollection = "InCollection"
   InProceedings = "InProceedings"
   MastersThesis = "MastersThesis"
   Misc = "Misc"
   PhdThesis = "PhdThesis"
   Proceedings = "Proceedings"
   Unpublished = "Unpublished"
   URL = "URL"

def get_bibtex_str(bibtex_dict):
    '''
    :param: bibtex_dict: Dictionary - BIBTEX record, must contain 'key' and 'entry_type' keys.
    :return: A single bibtex record string
    '''
    bibtex_lines = ['@{0} {{{1}'.format(bibtex_dict['entry_type'].upper(), bibtex_dict['key'])]
    for key, value in bibtex_dict.items():
        if key != 'entry_type' and key != 'key':  # @article{Sh:155,
            bibtex_lines.append('\t{0} = {{{1}}}'.format(key, value))
    return ',\n'.join(bibtex_lines) + '\n}'

def get_citation(bibtex_dict):
    '''
    :param bibtex_dict:  "entry_type": "Article",
                         "key": "author2020",
                         "title": "Egyptology",
                         "author": "Author",
                         "year": "2020",
                         ...
    :return: Creates citation based on given bibtex dictionary: "Author. (2020). *Egyptology*."
    '''

    #  fetch the name of the temporal file that will be used for extracting bibtex entries
    with open(CONFIGURATIONS_BIBTEX, 'r') as config_file:
        try:
            r = re.compile(r"bibliography: ?'(.+)'")
            tmp_bib_database_file = r.search(config_file.read()).group(1)
        except AttributeError:
            raise Exception('Configuration file is not valid')

    #  generating the temporal bibtex database for containing necessary bibtex entries
    with open(tmp_bib_database_file, 'w+') as bibfile:
        bibfile.write(get_bibtex_str(bibtex_dict))

    # configure a command that will generate a citation according to the .csl file stated in constants
    if not CITATION_STYLE_FILE:
        command = 'pandoc -t markdown_strict --filter=pandoc-citeproc --standalone {0} -o {1}'. \
            format(CONFIGURATIONS_BIBTEX, TMP_CITATION_FILE)
    else:
        command = 'pandoc -t markdown_strict --csl={0} --filter=pandoc-citeproc --standalone {1} -o {2}'. \
            format(CITATION_STYLE_FILE, CONFIGURATIONS_BIBTEX, TMP_CITATION_FILE)

    #  generating a .md file (CITATION_FILE) with citations for every entry of the .bib database mentioned in
    #  CONFIGURATIONS file

    subprocess.run(command, shell=True, capture_output=True)

    #  extracting the citation from the generated .md file
    with open(TMP_CITATION_FILE, 'r') as f:
        citation = ' '.join(f.read().splitlines())

    #  deleting tmp files

    os.remove(tmp_bib_database_file)
    os.remove(TMP_CITATION_FILE)

    return citation
#
# def tst(bibtex_dict):
#     # pandoc -t markdown_strict --csl=apa.csl --filter=pandoc-citeproc --standalone bib_config_ris.md -o out.md todo
#     with open(CONFIGURATIONS_RIS, 'r') as config_file:
#         try:
#             r = re.compile(r"bibliography: ?'(.+)'")
#             tmp_bib_ris_file = r.search(config_file.read()).group(1)
#         except AttributeError:
#             raise Exception('Configuration file is not valid')
#
#     #  generating the temporal bibtex database for containing necessary bibtex entries
#     with open(tmp_bib_ris_file, 'w+') as ris_file:
#         ris_file.write(get_bibtex_str(bibtex_dict))
#
#     #  generating a .md file (CITATION_FILE) with citations for every entry of the .bib database mentioned in
#     #  CONFIGURATIONS file
#     subprocess.run('pandoc -t markdown_strict --csl={0} --filter=pandoc-citeproc --standalone {1} -o {2}'.
#                    format(CITATION_STYLE_FILE, CONFIGURATIONS_RIS, TMP_CITATION_FILE), shell=True, capture_output=True)
#
#     #  extracting the citation from the generated .md file
#     with open(TMP_CITATION_FILE, 'r') as f:
#         citation = ' '.join(f.read().splitlines())
#
#     #  deleting tmp files
#
#     return citation
#
# if __name__ == '__main__':
#     bibtex_data = {
#         "entry_type": "Article",
#         "key": "lastname2020",
#         "author": "Lastname",
#         "title": "Title",
#         "journal": "Egyptology",
#         "year": "2020"
#     }
#     print(tst(bibtex_data))


def add_biblio_item(POST_data, conn, c):
    '''
    Adds single biblio record to the table bibliography
    :param POST_data: must contain the fields:  bibtex_json (TEXT),
                                                added_by (INTEGER),
                                                abbreviation (TEXT),
                                                project_type (TEXT)
    '''
    try:
        abbr = None
        if 'abbreviation' in POST_data:
            abbr = POST_data['abbreviation']
        c.execute(
            """INSERT INTO {0} (
                  abbreviation,
                  description,
                  added_by,
                  project_type)
               VALUES (?,?,?,?)""".format(TABLE_NAME), (abbr,
                                                        POST_data['bibtex_json'],
                                                        POST_data['added_by'],
                                                        POST_data['project_type'])
            )
        new_id = c.lastrowid
        conn.commit()
        return new_id
    except sqlite3.Error as e:
        conn.rollback()
        raise e

def get_all_records_as_dict(c):
    results = {}
    row_items = c.execute('SELECT * FROM {0};'.format(TABLE_NAME))
    for record in row_items:
        results[record[0]] = {
            "abbreviation": record[1],
            "title": get_citation(json.loads(record[2]))
        }
    return results

def get_all_bibtex_as_dict(c):
    results = {}
    row_items = c.execute('SELECT * FROM {0};'.format(TABLE_NAME))
    for record in row_items:
        results[record[0]] = {
            "abbreviation" : record[1],
            "bibtex": str(b64encode(bytes(get_bibtex_str(json.loads(record[2])), 'utf8')))
        }
    return results

def get_record_by_id(c, id):
    record_dic = None
    c.execute('SELECT * FROM {0} WHERE id = (?)'.format(TABLE_NAME), (id,))
    record = c.fetchone()
    if record:
        record_dic = {
            "bibtex": record[2],
            "abbreviation": record[1]
        }
    return record_dic

def get_bibtex_by_id(c, id):
    bibtex_str = None
    c.execute('SELECT * FROM {0} WHERE id = (?)'.format(TABLE_NAME), (id,))
    record = c.fetchone()
    if record:
        bibtex_str = record[2]
    return bibtex_str

def get_bibtex_json_by_id(c, id):
    bibtex_json = None
    c.execute('SELECT * FROM {0} WHERE id = (?)'.format(TABLE_NAME), (id,))
    record = c.fetchone()
    if record:
        bibtex_json = json.loads(record[2])
    return bibtex_json

def update_biblio_item(id, PUT_data, conn, c):
    """
    Updates (PUT) single biblio record in the table bibliography
    :param PUT_data: must contain the fields:  bibtex_json (TEXT),
                                               added_by (INTEGER),
                                               abbreviation (TEXT)
                                               project_type (TEXT)
    :param id: the id of the entry to be updated
    """
    try:
        c.execute(
            """UPDATE {0} 
               SET abbreviation = ?, 
                   description = ?,
                   added_by = ?,
                   project_type = ?
               WHERE id = ?;""".format(TABLE_NAME), (PUT_data['abbreviation'],
                                                     PUT_data['bibtex_json'],
                                                     PUT_data['added_by'],
                                                     PUT_data['project_type'],
                                                     id))
        conn.commit()
    except sqlite3.Error as e:
        conn.rollback()
        raise e

def delete_biblio_item(id, conn, c):
    try:
        c.execute(
            """DELETE FROM {0}
               WHERE id = ?;""".format(TABLE_NAME), (id, )
        )
        conn.commit()
    except sqlite3.Error as e:
        conn.rollback()
        raise e

def get_next_id(conn, c):
    try:
        c.execute(
            """SELECT seq FROM sqlite_sequence 
               WHERE name = '{0}';""".format(TABLE_NAME)
        )
        res = c.fetchone()
        if not res:
            raise Exception("The table sqlite_sequence doesn't contain tuple for '{0}' table".format(TABLE_NAME))
        return res[0]
    except sqlite3.Error as e:
        conn.rollback()
        raise e

# def get_biggest_id(): # TODO clean
#     """
#     :return: the biggest ID in the database so far
#     """
#     global c
#     try:
#         conn = sqlite3.connect(f'../data/biblio.db')
#         c = conn.cursor()
#         c.execute(
#             """SELECT max(id) FROM {0};""".format(TABLE_NAME)
#         )
#         res = c.fetchone()
#         if not res:
#             raise Exception("The table '{0}' doesn't contain any entry".format(TABLE_NAME))
#         return res[0]
#     except sqlite3.Error as e:
#         print(f'Exception occured when accessing the database: {e}')
#     finally:
#         c.close()
